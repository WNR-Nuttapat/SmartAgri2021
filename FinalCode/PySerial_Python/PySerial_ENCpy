import serial
import time
import numpy as np
import math

# SER2 and SER3 for Recieving ENC
SER2 = serial.Serial('COM13', baudrate = 230400, timeout = 0) # ENC 4 RotateMotor
SER3 = serial.Serial('COM7', baudrate = 230400, timeout = 0) # ENC 4 DriveMotor
time.sleep(1)

PWMData=[0,0,0,0,0,0,0,0]

x = [-0.2555,0.2555,-0.2555,0.2555]
y = [0.3725,0.3725,-0.3725,-0.3725]
wheelradius=0.0735

def getTheta(v,w):
    a = []
    b = []
    
    for i in range(len(x)):
        if w!=0:
            angle=math.atan(y[i]/(v/w - x[i]))
        else:
            angle=0
        a.append(angle)
        b.append(angle*180/math.pi)
    
    return b

def getVelocity(v,w):
    a = []
    b = []
    for i in range(len(x)):
        if w!=0:
            vel=w*math.sqrt(math.pow(v/w - x[i],2) + math.pow(y[i],2))
        else:
            vel=v
        a.append(vel)
        b.append(vel*60/(2*math.pi*wheelradius))

    return b

# #for Drive Motor usually use Kp and Ki
# DriveMotor_Target=[0,0,0,0]
# # DriveMotor_Target=getVelocity(velocity,omega)
# drv_kp=[1,1,1,1]
# drv_ki=[0,0,0,0]
# drv_kd=[0,0,0,0]

# #for Rotate Motor usually use only Kp
# RotateMotor_Target=[0,90,180,270]
# # RotateMotor_Target=getTheta(velocity,omega)
# rot_kp=[1,1,1,1]
# rot_ki=[0.5,0.5,0.5,0.5]
# rot_kd=[0,0,0,0]



MOTOR_DEG=[0,0,0,0]
# rot_prev_time=[time.time(),time.time(),time.time(),time.time()]


# MOTOR_TPR=[100,100,100,100] #Motor Tick pre Rev (For DriveMotor)
MOTOR_TICK=[0,0,0,0]
# MOTOR_TICK_prev=[0,0,0,0]
# drv_prev_time=[time.time(),time.time(),time.time(),time.time()]  

RotateENC_Complete=0
def RecievedENCfromARD2():
    global RotateENC_Complete,MOTOR_DEG
    ARD2Data = (SER2.readline()[:-2]).decode('ascii') #ENC from DriveMotor
    RotateENC=ARD2Data.split(',')
    if(len(RotateENC)==5 and RotateENC[0]=='ROT'):
        MOTOR_DEG[0]=RotateENC[1]
        MOTOR_DEG[1]=RotateENC[2]
        MOTOR_DEG[2]=RotateENC[3]
        MOTOR_DEG[3]=RotateENC[4]
        RotateENC_Complete=1
        return MOTOR_DEG
    else:
        pass

DriveENC_Complete=0
def RecievedENCfromARD3():
    global DriveENC_Complete,MOTOR_TICK
    ARD3Data = (SER3.readline()[:-2]).decode('ascii') #ENC from DriveMotor
    DriveENC=ARD3Data.split(',')
    if(len(DriveENC)==5 and DriveENC[0]=='DRV'):
        MOTOR_TICK[0]=DriveENC[1]
        MOTOR_TICK[1]=DriveENC[2]
        MOTOR_TICK[2]=DriveENC[3]
        MOTOR_TICK[3]=DriveENC[4]
        DriveENC_Complete=1
        return MOTOR_TICK
    else:
        pass

# pos_prev_error=[0,0,0,0]
# pos_eintegral=[0,0,0,0]
# def PID_PositionControl(target_val,curr_val,dt,k):
    
#     global rot_kp,rot_ki,rot_kd,pos_prev_error,pos_eintegral

#     error=target_val-curr_val
#     pos_eintegral[k]=pos_eintegral[k]+(error*dt)
#     ediff=(error-pos_prev_error[k])/dt

#     u=(rot_kp[k]*error)+(rot_ki[k]*pos_eintegral[k])+(rot_kd[k]*ediff)

#     pos_prev_error[k]=error

#     pwm=u
#     if pwm>255:
#         pwm=255
#     elif pwm<-255:
#         pwm=-255

#     return pwm
    

# spd_prev_error=[0,0,0,0]
# spd_eintegral=[0,0,0,0]
# def PID_SpeedControl(target_val,curr_val,dt,k):
    
#     global drv_kp,drv_ki,drv_kd,spd_prev_error,spd_eintegral

#     error=target_val-curr_val
#     spd_eintegral[k]=spd_eintegral[k]+(error*dt)
#     ediff=(error-spd_prev_error[k])/dt

#     u=(drv_kp[k]*error)+(drv_ki[k]*spd_eintegral[k])+(drv_kd[k]*ediff)

#     spd_prev_error[k]=error

#     pwm=u
#     if pwm>255:
#         pwm=255
#     elif pwm<-255:
#         pwm=-255

#     return pwm

while(1):

    DEG=RecievedENCfromARD2()
    if(RotateENC_Complete==1):
        print("Rotate")    
        print(DEG)
        # for i in range (0,4):
        #     curr_time=time.time()
        #     rot_deltatime=(curr_time-rot_prev_time[i])/60
        #     val = PID_PositionControl(RotateMotor_Target[i],MOTOR_DEG,rot_deltatime,i)
        #     PWMData[i]=val

        RotateENC_Complete=0

    TICK=RecievedENCfromARD3()
    if(DriveENC_Complete==1):
        print("Drive")
        print(TICK)
        # for j in range (0,4):
        #     curr_time=time.time()
        #     drv_deltatime=(curr_time-drv_prev_time[j])/60
        #     delta_TICK=MOTOR_TICK[j]-MOTOR_TICK_prev[j]
        #     RPM=(delta_TICK/MOTOR_TPR[j])/drv_deltatime

        #     val=PID_SpeedControl(DriveMotor_Target[j],RPM,drv_deltatime,j)

        #     PWMData[j+4]=val

        #     MOTOR_TICK_prev[0]=MOTOR_TICK[0]
        
        DriveENC_Complete=0
